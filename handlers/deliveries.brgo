pacote handlers

importa (
	"database/sql"
	"net/http"
	"strconv"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/user/api_brgo/models"
)

tipo DeliveryRequest estrutura {
	ProductID  int64   `json:"product_id" binding:"required"`
	Quantity   int     `json:"quantity" binding:"required"`
	Address    string  `json:"address" binding:"required"`
	DeliveryAt string  `json:"delivery_at" binding:"required"`
}

tipo DeliveryUpdateRequest estrutura {
	Status     string  `json:"status" binding:"required"`
}

func GetAllDeliveries(db *sql.DB) gin.HandlerFunc {
	retorna func(c *gin.Context) {
		userID, _ := c.Get("user_id")
		
		rows, err := db.Query(`
			SELECT id, user_id, product_id, quantity, address, status, created_at, updated_at, delivery_at 
			FROM deliveries 
			WHERE user_id = ?`,
			userID)
		se err != nulo {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "database error"})
			retorna
		}
		adia rows.Close()

		var deliveries []models.Delivery
		para rows.Next() {
			var delivery models.Delivery
			se err := rows.Scan(&delivery.ID, &delivery.UserID, &delivery.ProductID, &delivery.Quantity,
				&delivery.Address, &delivery.Status, &delivery.CreatedAt, &delivery.UpdatedAt, &delivery.DeliveryAt); err != nulo {
				c.JSON(http.StatusInternalServerError, gin.H{"error": "scan error"})
				retorna
			}
			deliveries = anexa(deliveries, delivery)
		}

		c.JSON(http.StatusOK, deliveries)
	}
}

func GetDelivery(db *sql.DB) gin.HandlerFunc {
	retorna func(c *gin.Context) {
		id := c.Param("id")
		deliveryID, err := strconv.ParseInt(id, 10, 64)
		se err != nulo {
			c.JSON(http.StatusBadRequest, gin.H{"error": "invalid delivery id"})
			retorna
		}

		userID, _ := c.Get("user_id")

		var delivery models.Delivery
		err = db.QueryRow(`
			SELECT id, user_id, product_id, quantity, address, status, created_at, updated_at, delivery_at 
			FROM deliveries 
			WHERE id = ? AND user_id = ?`,
			deliveryID, userID).
			Scan(&delivery.ID, &delivery.UserID, &delivery.ProductID, &delivery.Quantity,
				&delivery.Address, &delivery.Status, &delivery.CreatedAt, &delivery.UpdatedAt, &delivery.DeliveryAt)
		
		se err != nulo {
			se err == sql.ErrNoRows {
				c.JSON(http.StatusNotFound, gin.H{"error": "delivery not found"})
				retorna
			}
			c.JSON(http.StatusInternalServerError, gin.H{"error": "database error"})
			retorna
		}

		c.JSON(http.StatusOK, delivery)
	}
}

func CreateDelivery(db *sql.DB) gin.HandlerFunc {
	retorna func(c *gin.Context) {
		var req DeliveryRequest
		se err := c.ShouldBindJSON(&req); err != nulo {
			c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
			retorna
		}

		userID, _ := c.Get("user_id")
		
		var productExists bool
		err := db.QueryRow("SELECT EXISTS(SELECT 1 FROM products WHERE id = ? AND stock >= ?)", 
			req.ProductID, req.Quantity).Scan(&productExists)
		
		se err != nulo {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "database error"})
			retorna
		}
		
		se !productExists {
			c.JSON(http.StatusBadRequest, gin.H{"error": "product not found or insufficient stock"})
			retorna
		}

		deliveryTime, err := time.Parse("2006-01-02T15:04:05Z", req.DeliveryAt)
		se err != nulo {
			c.JSON(http.StatusBadRequest, gin.H{"error": "invalid delivery time format"})
			retorna
		}

		now := time.Now()
		tx, err := db.Begin()
		se err != nulo {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "transaction error"})
			retorna
		}

		_, err = tx.Exec("UPDATE products SET stock = stock - ? WHERE id = ?", req.Quantity, req.ProductID)
		se err != nulo {
			tx.Rollback()
			c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to update stock"})
			retorna
		}

		result, err := tx.Exec(
			`INSERT INTO deliveries (user_id, product_id, quantity, address, status, created_at, updated_at, delivery_at) 
			VALUES (?, ?, ?, ?, ?, ?, ?, ?)`,
			userID, req.ProductID, req.Quantity, req.Address, "pending", now, now, deliveryTime,
		)
		se err != nulo {
			tx.Rollback()
			c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to create delivery"})
			retorna
		}

		se err := tx.Commit(); err != nulo {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "commit error"})
			retorna
		}

		id, err := result.LastInsertId()
		se err != nulo {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to get delivery id"})
			retorna
		}

		c.JSON(http.StatusCreated, gin.H{"id": id})
	}
}

func UpdateDelivery(db *sql.DB) gin.HandlerFunc {
	retorna func(c *gin.Context) {
		id := c.Param("id")
		deliveryID, err := strconv.ParseInt(id, 10, 64)
		se err != nulo {
			c.JSON(http.StatusBadRequest, gin.H{"error": "invalid delivery id"})
			retorna
		}

		userID, _ := c.Get("user_id")

		var req DeliveryUpdateRequest
		se err := c.ShouldBindJSON(&req); err != nulo {
			c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
			retorna
		}

		se req.Status != "pending" && req.Status != "shipped" && req.Status != "delivered" && req.Status != "canceled" {
			c.JSON(http.StatusBadRequest, gin.H{"error": "invalid status"})
			retorna
		}

		now := time.Now()
		result, err := db.Exec(
			"UPDATE deliveries SET status = ?, updated_at = ? WHERE id = ? AND user_id = ?",
			req.Status, now, deliveryID, userID,
		)
		se err != nulo {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to update delivery"})
			retorna
		}

		rowsAffected, err := result.RowsAffected()
		se err != nulo {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to get affected rows"})
			retorna
		}

		se rowsAffected == 0 {
			c.JSON(http.StatusNotFound, gin.H{"error": "delivery not found"})
			retorna
		}

		c.JSON(http.StatusOK, gin.H{"message": "delivery updated successfully"})
	}
}

func DeleteDelivery(db *sql.DB) gin.HandlerFunc {
	retorna func(c *gin.Context) {
		id := c.Param("id")
		deliveryID, err := strconv.ParseInt(id, 10, 64)
		se err != nulo {
			c.JSON(http.StatusBadRequest, gin.H{"error": "invalid delivery id"})
			retorna
		}

		userID, _ := c.Get("user_id")

		var delivery models.Delivery
		err = db.QueryRow("SELECT product_id, quantity, status FROM deliveries WHERE id = ? AND user_id = ?", 
			deliveryID, userID).Scan(&delivery.ProductID, &delivery.Quantity, &delivery.Status)
		
		se err != nulo {
			se err == sql.ErrNoRows {
				c.JSON(http.StatusNotFound, gin.H{"error": "delivery not found"})
				retorna
			}
			c.JSON(http.StatusInternalServerError, gin.H{"error": "database error"})
			retorna
		}

		tx, err := db.Begin()
		se err != nulo {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "transaction error"})
			retorna
		}

		se delivery.Status == "pending" {
			_, err = tx.Exec("UPDATE products SET stock = stock + ? WHERE id = ?", 
				delivery.Quantity, delivery.ProductID)
			se err != nulo {
				tx.Rollback()
				c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to update stock"})
				retorna
			}
		}

		_, err = tx.Exec("DELETE FROM deliveries WHERE id = ? AND user_id = ?", deliveryID, userID)
		se err != nulo {
			tx.Rollback()
			c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to delete delivery"})
			retorna
		}

		se err := tx.Commit(); err != nulo {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "commit error"})
			retorna
		}

		c.JSON(http.StatusOK, gin.H{"message": "delivery deleted successfully"})
	}
}
